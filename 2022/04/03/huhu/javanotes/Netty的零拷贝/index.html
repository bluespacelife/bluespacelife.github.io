<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    
<link rel="stylesheet" href="/css/bluespacelife.css">


    <!-- system0 -->
    
<link rel="stylesheet" href="/css/system0/system0.css">

     
<meta name="generator" content="Hexo 5.4.0"></head>
<head>
    <meta charset="utf-8">
    
    
<link rel="stylesheet" href="/css/bluespacelife.css">


    <!-- system1 -->
    
<link rel="stylesheet" href="/css/system1/system1.css">

     
</head>


<script src="/js/jquery.slim.min.js"></script>


<script src="/js/bluespacelife.js"></script>



<body>
  <div id="system0-post-container" class="system0-post-container" hidden="hidden">
    <div class="system0-banner">
    星辰
</div>

    <div class="system0-post-atricle">
      <div class="system0-post-atricle-title">
        <h1>
          Netty的零拷贝
        </h1>
      </div>
      <div class="system0-post-atricle-author">

      </div>
      <div class="system0-post-atricle-content">
        <h2 id="Netty的零拷贝实现？"><a href="#Netty的零拷贝实现？" class="headerlink" title="Netty的零拷贝实现？"></a>Netty的零拷贝实现？</h2><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li>
<li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li>
<li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题</li>
<li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作</li>
<li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li>
<li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭</li>
</ul>

      </div>
    </div>
  
    <div id="paginator">
      
    </div>

    <div class="system0-footer">
    <div class="system0-footer-copyright">
        Copyright © 2022 壶壶
    </div>
</div>
  </div>

  <div id="system1-post-container" class="system1-post-container" hidden="hidden">
    <div class="system1-banner">
    大海
</div>

    <div class="system1-post-atricle">
      <div class="system1-post-atricle-title">
        <h1>
          Netty的零拷贝
        </h1>
      </div>
      <div class="system1-post-atricle-author">

      </div>
      <div class="system1-post-atricle-content">
        <h2 id="Netty的零拷贝实现？"><a href="#Netty的零拷贝实现？" class="headerlink" title="Netty的零拷贝实现？"></a>Netty的零拷贝实现？</h2><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li>
<li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li>
<li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题</li>
<li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作</li>
<li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li>
<li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭</li>
</ul>

      </div>
    </div>
  
    <div id="paginator">
      
    </div>
    
    <div class="system1-footer">
    <div class="system1-footer-copyright">
        Copyright © 2022 冰冰
    </div>
</div>
  </div>

  <script type="text/javascript">
    $(function() {
      let system = getUrlParam('system');
      if ("0" === system) {
        $("#system0-post-container").show();
      } else if ("1" === system) {
        $("#system1-post-container").show();
      }
    });
  </script>
</body>

</html>