<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    
<link rel="stylesheet" href="/css/bootstrap.min.css">

    
<link rel="stylesheet" href="/css/bluespacelife.css">


    <!-- system0 -->
    
<link rel="stylesheet" href="/css/system0/system0.css">

     
<meta name="generator" content="Hexo 5.4.0"></head>


<script src="/js/jquery.slim.min.js"></script>


<script src="/js/bluespacelife.js"></script>



<body>
  <article id="post">
    <h1>
      Java NIO 的组成元素
    </h1>
    <h2 id="NIO的组成？"><a href="#NIO的组成？" class="headerlink" title="NIO的组成？"></a>NIO的组成？</h2><ul>
<li>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</li>
<li>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</li>
<li>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit</li>
<li>rewind方法 ： 重绕此缓冲区，将position置为0</li>
<li>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</li>
<li>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次</li>
<li>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</li>
<li>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</li>
<li>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</li>
<li>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取</li>
<li>NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</li>
</ul>

  </article>

  <div id="paginator">
    
  </div>
</body>

</html>