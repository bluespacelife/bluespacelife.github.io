<!DOCTYPE html>
<html>
<head>
    
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">

<link rel="shortcut icon" type="image/x-icon" href="/icon.png">
</link>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HETQ51XJBF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HETQ51XJBF');
</script>



<link rel="stylesheet" href="/css/bluespacelife.css">



    <!-- google advertisement -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script>


    <!-- system0 -->
    
<link rel="stylesheet" href="/css/system0/system0.css">

     
<meta name="generator" content="Hexo 5.4.0"></head>
<head>

    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">

<link rel="shortcut icon" type="image/x-icon" href="/icon.png">
</link>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HETQ51XJBF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HETQ51XJBF');
</script>



<link rel="stylesheet" href="/css/bluespacelife.css">



    <!-- google advertisement -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script>


    <!-- system1 -->
    
<link rel="stylesheet" href="/css/system1/system1.css">

     
</head>


<script src="/js/jquery.slim.min.js"></script>


<script src="/js/bluespacelife.js"></script>



<body>
  <input id="system" type="text" hidden value="0" />

  <div id="system0-post-container" class="system0-post-container" hidden="hidden">
    <div class="system0-banner">
    星辰
</div>

    <div id="system0-post-atricle" class="system0-post-atricle">
      <div class="system0-post-atricle-title">
        <h1>
          Netty专题
        </h1>
      </div>
      <div class="system0-post-atricle-author">

      </div>
      <div class="system0-post-atricle-content">
        <h2 id="BIO、NIO和AIO的区别"><a href="#BIO、NIO和AIO的区别" class="headerlink" title="BIO、NIO和AIO的区别"></a>BIO、NIO和AIO的区别</h2><ul>
<li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大</li>
<li>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源</li>
<li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理</li>
<li>AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li>
<li>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的，而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的</li>
<li>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性，基于Reactor线程模型</li>
<li>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<h2 id="NIO的组成"><a href="#NIO的组成" class="headerlink" title="NIO的组成"></a>NIO的组成</h2><ul>
<li>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</li>
<li>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</li>
<li>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit</li>
<li>rewind方法 ： 重绕此缓冲区，将position置为0</li>
<li>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</li>
<li>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次</li>
<li>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</li>
<li>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</li>
<li>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</li>
<li>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取</li>
<li>NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</li>
</ul>
<h2 id="Netty的特点"><a href="#Netty的特点" class="headerlink" title="Netty的特点"></a>Netty的特点</h2><ul>
<li>一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持</li>
<li>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。</li>
<li>采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理</li>
<li>可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持</li>
<li>可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf</li>
<li>通过引用计数器及时申请释放不再引用的对象，降低了GC频率</li>
<li>使用单线程串行化的方式，高效的Reactor线程模型</li>
<li>大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用</li>
</ul>
<h2 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h2><ul>
<li>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理</li>
<li>单线程模型：<ul>
<li>所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的</li>
<li>既要接收客户端的连接请求，向服务端发起连接，又要发送/读取请求或应答/响应消息</li>
<li>一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适</li>
</ul>
</li>
<li>多线程模型：<ul>
<li>有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求</li>
<li>NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送</li>
<li>1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题</li>
<li>但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题</li>
</ul>
</li>
<li>主从多线程模型：<ul>
<li>Acceptor 线程用于绑定监听端口，接收客户端连接</li>
<li>将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上</li>
<li>用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作</li>
</ul>
</li>
</ul>
<h2 id="Netty的高性能表现在哪些方面？"><a href="#Netty的高性能表现在哪些方面？" class="headerlink" title="Netty的高性能表现在哪些方面？"></a>Netty的高性能表现在哪些方面？</h2><ul>
<li>心跳，对服务端：会定时清除闲置会话inactive(netty5)，对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态</li>
<li>串行无锁化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</li>
<li>可靠性，链路有效性检测：链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</li>
<li>Netty安全性：支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。</li>
<li>高效并发编程的体现：volatile的大量、正确使用；CAS和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）</li>
<li>流量整型的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。</li>
<li>TCP参数配置：SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</li>
</ul>
<h2 id="Netty的零拷贝实现"><a href="#Netty的零拷贝实现" class="headerlink" title="Netty的零拷贝实现"></a>Netty的零拷贝实现</h2><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li>
<li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li>
<li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题</li>
<li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作</li>
<li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li>
<li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭</li>
</ul>
<h2 id="TCP-粘包-拆包的原因及解决方法？"><a href="#TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="TCP 粘包/拆包的原因及解决方法？"></a>TCP 粘包/拆包的原因及解决方法？</h2><ul>
<li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li>
<li>TCP粘包/分包的原因：<ul>
<li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象</li>
<li>而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象</li>
<li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li>
<li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片</li>
</ul>
</li>
<li>解决方法</li>
<li>消息定长：FixedLengthFrameDecoder类</li>
<li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类：DelimiterBasedFrameDecoder</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类，分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包</li>
</ul>
<h2 id="NIOEventLoopGroup源码？"><a href="#NIOEventLoopGroup源码？" class="headerlink" title="NIOEventLoopGroup源码？"></a>NIOEventLoopGroup源码？</h2><ul>
<li>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop</li>
<li>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回。如果taskQueue没有元素，执行 select(oldWakenUp) 方法</li>
<li>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug</li>
<li>rebuildSelector方法先通过openSelector方法创建一个新的selector。然后将old selector的selectionKey执行cancel。最后将old selector的channel重新注册到新的selector中。rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</li>
<li>接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件</li>
<li>最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行</li>
<li>每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询</li>
<li>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。</li>
<li>内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配</li>
<li>ByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读/写模式，读取和写入索引分开；方法链；引用计数基于AtomicIntegerFieldUpdater用于内存回收；PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象</li>
</ul>

      </div>
    </div>
  
    <div id="paginator">
      
    </div>

    <div class="system0-footer">
    <div class="system0-footer-copyright">
        Copyright © 2022 壶壶
    </div>
</div>
  </div>

  <div id="system1-post-container" class="system1-post-container" hidden="hidden">
    <div class="system1-banner">
    大海
</div>

    <div id="system1-post-atricle" class="system1-post-atricle">
      <div class="system1-post-atricle-title">
        <h1>
          Netty专题
        </h1>
      </div>
      <div class="system1-post-atricle-author">

      </div>
      <div class="system1-post-atricle-content">
        <h2 id="BIO、NIO和AIO的区别"><a href="#BIO、NIO和AIO的区别" class="headerlink" title="BIO、NIO和AIO的区别"></a>BIO、NIO和AIO的区别</h2><ul>
<li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大</li>
<li>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源</li>
<li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理</li>
<li>AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li>
<li>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的，而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的</li>
<li>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性，基于Reactor线程模型</li>
<li>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<h2 id="NIO的组成"><a href="#NIO的组成" class="headerlink" title="NIO的组成"></a>NIO的组成</h2><ul>
<li>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</li>
<li>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</li>
<li>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit</li>
<li>rewind方法 ： 重绕此缓冲区，将position置为0</li>
<li>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</li>
<li>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次</li>
<li>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</li>
<li>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</li>
<li>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</li>
<li>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取</li>
<li>NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</li>
</ul>
<h2 id="Netty的特点"><a href="#Netty的特点" class="headerlink" title="Netty的特点"></a>Netty的特点</h2><ul>
<li>一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持</li>
<li>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。</li>
<li>采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理</li>
<li>可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持</li>
<li>可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf</li>
<li>通过引用计数器及时申请释放不再引用的对象，降低了GC频率</li>
<li>使用单线程串行化的方式，高效的Reactor线程模型</li>
<li>大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用</li>
</ul>
<h2 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h2><ul>
<li>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理</li>
<li>单线程模型：<ul>
<li>所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的</li>
<li>既要接收客户端的连接请求，向服务端发起连接，又要发送/读取请求或应答/响应消息</li>
<li>一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适</li>
</ul>
</li>
<li>多线程模型：<ul>
<li>有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求</li>
<li>NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送</li>
<li>1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题</li>
<li>但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题</li>
</ul>
</li>
<li>主从多线程模型：<ul>
<li>Acceptor 线程用于绑定监听端口，接收客户端连接</li>
<li>将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上</li>
<li>用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作</li>
</ul>
</li>
</ul>
<h2 id="Netty的高性能表现在哪些方面？"><a href="#Netty的高性能表现在哪些方面？" class="headerlink" title="Netty的高性能表现在哪些方面？"></a>Netty的高性能表现在哪些方面？</h2><ul>
<li>心跳，对服务端：会定时清除闲置会话inactive(netty5)，对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态</li>
<li>串行无锁化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</li>
<li>可靠性，链路有效性检测：链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</li>
<li>Netty安全性：支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。</li>
<li>高效并发编程的体现：volatile的大量、正确使用；CAS和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）</li>
<li>流量整型的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。</li>
<li>TCP参数配置：SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</li>
</ul>
<h2 id="Netty的零拷贝实现"><a href="#Netty的零拷贝实现" class="headerlink" title="Netty的零拷贝实现"></a>Netty的零拷贝实现</h2><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li>
<li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li>
<li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题</li>
<li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作</li>
<li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li>
<li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭</li>
</ul>
<h2 id="TCP-粘包-拆包的原因及解决方法？"><a href="#TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="TCP 粘包/拆包的原因及解决方法？"></a>TCP 粘包/拆包的原因及解决方法？</h2><ul>
<li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li>
<li>TCP粘包/分包的原因：<ul>
<li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象</li>
<li>而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象</li>
<li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li>
<li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片</li>
</ul>
</li>
<li>解决方法</li>
<li>消息定长：FixedLengthFrameDecoder类</li>
<li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类：DelimiterBasedFrameDecoder</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类，分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包</li>
</ul>
<h2 id="NIOEventLoopGroup源码？"><a href="#NIOEventLoopGroup源码？" class="headerlink" title="NIOEventLoopGroup源码？"></a>NIOEventLoopGroup源码？</h2><ul>
<li>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop</li>
<li>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回。如果taskQueue没有元素，执行 select(oldWakenUp) 方法</li>
<li>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug</li>
<li>rebuildSelector方法先通过openSelector方法创建一个新的selector。然后将old selector的selectionKey执行cancel。最后将old selector的channel重新注册到新的selector中。rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</li>
<li>接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件</li>
<li>最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行</li>
<li>每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询</li>
<li>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。</li>
<li>内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配</li>
<li>ByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读/写模式，读取和写入索引分开；方法链；引用计数基于AtomicIntegerFieldUpdater用于内存回收；PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象</li>
</ul>

      </div>
    </div>
  
    <div id="paginator">
      
    </div>
    
    <div class="system1-footer">
    <div class="system1-footer-copyright">
        Copyright © 2022 冰冰
    </div>
</div>
  </div>

  <script type="text/javascript">
    $(function() {
      let system = $("#system").val();
      if ("0" === system) {
        $("#system0-post-container").show();
      } else if ("1" === system) {
        $("#system1-post-container").show();
      } else {
        $("#system0-post-container").show();
      }

      let isMobile = isMobileBrowser();
      // alert(isMobile);
      if (isMobile) {
        $("#system0-post-atricle").css("width", "100%");
        $("#system1-post-atricle").css("width", "100%");
        $("#system1-post-atricle").css("font-size", "2.2em");
      } else {
        $("#system0-post-atricle").css("width", "60%");
        $("#system1-post-atricle").css("width", "60%");
        $("#system1-post-atricle").css("font-size", "1.2em");
      }
    });
  </script>
</body>

</html>